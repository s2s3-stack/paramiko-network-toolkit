栈
	仅一端进行删除和插入的线性表,能进行插入和删除的称为栈顶,另一端称为栈底(bottom)
		入栈操作及出栈操作只能在栈顶进行，实际上，只能看到栈顶元素，栈顶之下的所有元素都是不可见的，即不允许访问非栈顶元素。
	push:在栈顶插入一个元素
	pop:在栈顶删除一个元素
	栈中每一个元素的类型用:ELEMType
		typedef int ELEMType
	栈的基本操作:
		栈的抽象数据类型:Stack
		int initStack(stack *mys
		int clear(Stack *mys); //将栈 mys 清空
		int pop(Stack *mys,ELEMType *x); //将栈顶元素出栈
		int push(Stack *mys,ELEMType x); //将元素 x 入栈
		int gettop(SeqStack *mys,ELEMType *x);
		//获取栈顶元素(不出栈)
		int isEmpty(Stack *mys); //如果栈 mys 为空,则返回 1,否则返回 0
		int isFull(Stack *mys); //如果栈 mys 为满,则返回 1,否则返回 0
		栈的特性:
			后进先出
	栈的存储及实现
		顺序存储
			采用数组保存栈元素
			获取栈顶元素:
```				int gettop(SeqStack *mys,ELEMType *x)
				//返回栈顶元素（不出栈）
				{if(isEmpty(mys)==FALSE){ 
				*x=mys->element[mys->top-1]; #mys->element mys栈读取元素的位置
				return TRUE;
				}
				else{
				printf("栈空\n");
				return FALSE
				}
				}					
```


链式栈及其实现
	链式栈
		仅在表头操作的单链表
		链式栈的定义
```
			typedef int ELEMType; #将int类型别名为ELEMType
			typedef struct node{ //开始设计叫node的结构体
			ELEMType data; #定义类型是数字,也就是说这里存的是需要处理的数字
			struct node *next; #指向下一个格子的指针
			LinkStackNode; #struct node 的别名
			typedef LinkStackNode *LinkStack; //将LinkStackNode * 起一个别名LinkStack,链式栈
```
通过pop判断栈不为空,并且出栈后讲栈顶元素的值通过x返回给调用者,元素所占用的空间要释放
```
int pop(LinkStack *mys,ELEMType *x) //此处的*mys是二级指针,是指向栈顶指针的指针,通过*x带回出栈的数据,int返回状态码(ture & False)
{LinkStackNode *temp; #定义临时指针,保存栈顶节点的地址
if(isEmpty(*mys)==FALSE){ #判空
*x=(*mys)->data; #*x作为
temp=(*mys);
*mys=(*mys)->next;
free(temp);
return TRUE;
}
else{
printf("栈空\n");
return FALSE;
}
}
```