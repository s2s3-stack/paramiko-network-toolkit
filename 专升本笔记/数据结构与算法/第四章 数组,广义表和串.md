## 串
	内容受限的线性表,表中的内容必须是字符
		零个或多个任意字符组成的有限序列
			S=“a1a2....an”
			//s为穿名
			//后面的值为串值
			//n为串长,n=0为空串
	术语:
		子串
			串中任意个连续字符组成的子序列称为该串的子串
			例如:“abcd”的字串有:
				“”,“a”,"ab","abc","abcd","abcde"
				真字串是指不包含自身的所有字串
		主串
			包含字串的串相应地称为主串
		字符位置
			字符再序列中的序号为该字符在串中的位置
		字串位置:
			字串第一个字符在主串中的位置
		空格串:
			由一个或多个空格组成的串,与空串不同
		串相等
			当且仅当两个串的长度相等并且各个对应位置的字符都相同时,这两个串才是相等的
			如:
				“abcd” != "abc"
				"abcd" != "abcde"
					所有空串都是相等的
```
例如:
字符串a,b,c,d
a="BEI"
b="JING"
c="BEIJING"
d="BEIJING"
它们的长度是:3,4,7,8
c的字串:a b
d的字串:a b
a在c的位置是:1  a在d的位置是:1
b在c的位置是:4  b在d的位置是:5
```
案例引入
	病毒感染检测:
		研究者将人的DNA和病毒的DNA均表示成由一些字母组成的字符串序列
			例如:
				假设病毒的DNA序列为baa,患者1的DNA序列为aaabbba,则感染,患者2的DNA序列为babbba,则未感染
					注意:人的DNA序列是线性的,而病毒的DNA序列是环状的
串的类型定义
	ADT String{
		数据对象
		数据关系
		基本操作
			StrAssign(&T,chars) //串赋值
			StrCompare(S,T) //串比较
			StrLength(S) //求串长
			Concat(&T,S1,S2) //串连结
			==index(S,T,pos) //字串的位置==
	}ADT String
串的存储结构
顺序存储(实际用的最多)
```c
#define MAXLEN 255

typedef struct{
	char ch[MAXLEN + 1] //存储串的一维数组
	int length; //串的当前长度
}SString
```
链式存储
	优点:操作方便
	缺点:存储密度较低
		存储密度=串值所占的存储/实际分配的存储
块链结构
```c
#define CHUNKSIZE 80 //快的大小由用户定义

typedef struct Chunk{
	char ch[CHUNKSIZE];
	struct Chunk *next;
}Chunk;

typedef struct{
	Chunk *head,*tail; //串的头指针和尾指针
	int curlen; //串的当前长度
}LString //字符串的块链结构
```
算法目的:
	确定主串中所含字串(模式串)第一次出现的位置
算法应用:
	搜索引擎,拼写检查,语言翻译,数据压缩
算法种类:
	BF算法(简单匹配法)穷举法
		S :a a a a b c d 主串:正文串
		T:          a b c    字串:模式
		匹配失败:
			i=i-j+2(回溯)
			j=1(重头开始)
		设计思想:
			index(S,T,pos)
				将主串的第pos个字符和模式串的第一个字符比较
					若相等,继续逐个比较后续字符
					若不等,从主串的下一个字符起,重新与模式串的第一个字串比较
						直到主串的一个连续字串字符序列与模式串相等.返回值为S中与T匹配的子序列的第一个字符的序号,即匹配成功
						否则,匹配失败,返回值为0
```c
int index BF(SString S,SString T){
	int i=1,j=1
	while (i <= S.length && j<= T.length){
		if (s.ch[i]==t.ch[j]){++i;++j;} //主串和字串依次匹配下一个字符
		else {i=i-j+2;j=1;} //主串,字串指针回溯重新开始下一次匹配
	}
}
if (j>=T.length) return i-T.length; //返回匹配的第一个字符的下标
else retun 0; //模式匹配不成功

时间复杂度
	总次数:（n-m）*m+m=(n-m+1)*m
	若m<<n,则算法复杂度O(n*m)
```
KMP算法
	利用已经部分匹配的结果而加快模式串的滑动速度?
	且主串S的指针i不必回溯,可提速到O(n+m)!
```c
int index KMP (SString S,SString T,int pos){
	i=pos,j=1;
	while (i<S.length && j<T.length){
		if (j==0)||S.ch[i]==T.ch[j]{i++;j++;}
		else
			j=next[j]; //i不变,j后退
	}
	if(j>T.length) return i-T.length; //匹配成功
	else return 0; //返回不匹配标志
}
```
![[Pasted image 20260207193805.png]]
## 数组
	按一定格式排列起来的
		具有相同类型的数据元素的集合
		一维数组:若线性表中的数据元素为非结构的简单元素,则为一维数组
	一维数组的逻辑结构:线性结构,定长的线性表
	二维数组:若一维数组中的数据元素又是一维数组结构,则称为二维数组
		声明格式:数据类型 变量名称[行数][列数]
			int num[5][8]
	三维数组:若二维数组中的元素又是一个一维数组,则称为三维数组
	线性表结构是数组结构的一个特例
	而数组结构又是线性表结构的拓展
	数组特点:
		结构固定,定义后，维数和维界不再改变
	数组的基本操作:
		除了结构的初始化和销毁之外,只有取元素和修改元素值的操作
	n维数组的抽象数据类型定义
		数据对象
			ji = 0,...bi-1,i=1,2,...,n ji为数组元素第i维的下标
			D = {aj1j2...jn | aj1j2...jn}
		数据关系
	基本操作:
```
initarray(&A,n,bound1,...boundn) //构造数组A
DestroyArray(&A) //销毁数组A
Value(A,&e,index1,...,indexn) //取数组元素值
Assign(A,&e,index1...,indexn) //给数组元素赋值
```
数组的顺序存储
	一维数组:
	例如:
		有数组定义:int a[5]
		每个元素占用4字节,假设a[0]存储在2000单元,a[3]地址是多少？
			LOC(0)=A=2000 L=4
			LOC(3) = 3 * 4 + 2000 
	二维数组:
		行优先
			行序为主序
				设数组开始存储位置LOC(0,0),存储每个元素需要L个存储单元
					数组元素a[i][j]的存储位置是:LOC(i,J)=LOC(0,0)+(n*i+j)*L
		列优先
			列序为主序
	三维数组
		按页/行/存放,页优先的顺序存储
		LOC(i1,i2,i3) = a + i1 * m2 * m3 + i2 * m3 + i3
					    前i1页总元         第i1页的前前i2行总元素个数
					    素个数    
	特殊矩阵的压缩存储
		矩阵:一个由m*n个元素排成的m行n列的表	
		矩阵的常规存储:
			将矩阵描述为一个二维数组
		矩阵的常规存储的特点:
			可以对其元素进行随机存取
			矩阵的运算非常简单,存储的密度为1
		不适宜常规存储的矩阵:值相同的元素很多且呈某种规律分布;零元素多
		矩阵的压缩存储:为多个相同的非零元素只分配一个存储空间,对零元素不分配空间
		什么样的矩阵能够压缩？
			一些特殊矩阵,如:对称矩阵,对角矩阵,三角矩阵,稀疏矩阵等
		什么是稀疏矩阵？
			矩阵中非零元素的个数较少(一般小于5%)
	对称矩阵
		特点:在n*n的矩阵a中,满足如下性质:
			aij=aji(1<=i,j<=n)
		存储方法:
			只存储下(或上)三角(包括主对角线)的数据元素,共占用==n(n+1)/2==个元素空间
		计算下标K的位置:
			(1+n-1) * (n-1)/2=n/2 * n-1
	三角矩阵
		特点:对角线一下(或者以上)的数据元素(不包括对角线)全部为常数c
		存储方法:
			重复元素c共享一个元素存储空间,共占用n(n+1)/2+1个元素
		上三角矩阵
			![[Pasted image 20260208083959.png]]
		下三角矩阵
			![[Pasted image 20260208084008.png]]
	对角矩阵
		特点:
			在n * n的方针中,所有非零元素都集中在以==主对角线为中心==的带状区域中,在区域外的值全为0,则称为对角矩阵
		存储方法:
			以对角线的顺序存储
	稀疏矩阵
		
## 广义表
	线性结构的推广