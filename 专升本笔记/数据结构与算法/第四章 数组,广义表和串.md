数组及广义表
	数组的基本操作:
		Create(); //创建一个空的数组
		Store(index,value);
		//添加数据(index,value),同时删除有相同 index 值的数据对(如果存在)
		Retrieve(index);//返回下标为 index 的 value 值
```
p=​1340​
  0250
  ​0060
  ​0000​​

我们要找的是 `p[1][2]`：

1. **第一个下标 `[1]`**：代表行号。
    - 我们去找**第 1 行**（也就是人类眼中的第二行）。
    - 这一行的数据是：`3, 2, 0, 0`。
2. **第二个下标 `[2]`**：代表列号。
    - 在这一行（`3, 2, 0, 0`）中，我们去找**第 2 列**（也就是人类眼中的第三列）。
    - 第 0 列是 `3`
    - 第 1 列是 `2`
    - **第 2 列是 `0`**
```
### 顺序存储方式
	行主序方式
		同一行中自左至右的次序进行连续编号
```
map(i1,i2)=i1*u2+i2
其中u2是数组的列数。
例如:
现在用前面给出的 3 行 6 列的数组 D2Array 进行验证。D2Array 的列数为 6，故映射公
式变成：
map(i1,i2)=6*i1+i2
```
	列主序方式
		按行自上而下
```
map(i1,i2)=i2*u2+i1
其中u2是数组的行数。
```
例题:
二维数组 A[10][5]采用行主序方式存储，每个数据元素占 4 个存储单元，若
A[0][4]的存储地址是 1000，则 A[8][4]的存储地址是多少?
```
给定的数组 A是10行5列，需要从A[0][4]的存储地址反推出数组A的首地址，然后再计算A[8][4]的存储地址。  
行主序所对应的映射函数为：map(i1,I2)=I1*U2+I2,本题中,u2=5.map(0,4)=4,每个元素占4个存储单元,表明A[0][0]的存储地址为1000-4*4=984,根据公式计算,A[8][4]的映射编号是map(8,4)=8*5+4=44,存储地址为984+44*4=1160
```

矩阵的压缩存储
	对称矩阵的压缩存储
		定义：A[i][j] == A[j][i] 永远成立（主对角线对称）
		将二维数组压缩成一维数组
		方式一：按“行优先”只存下三角（包含对角线）		
			只存 i ≥ j 的元素
			一维数组叫 sa[]， 长度 n(n+1)/2
			位置映射公式:
				k = i*(i+1)//2 + j
		方式二：按“列优先”只存上三角（包含对角线）
			只存 i ≤ j的元素
				k = j*(j+1)//2 + i （i ≤ j 时）
			上三角常用口诀：“j 固定，i 从 0 到 j”
	上下三角矩阵的压缩存储
	稀疏矩阵的压缩存储
		矩阵里绝大部分元素都是 0，只有很少一部分是非 0 元素，这种矩阵就叫稀疏矩阵
			存储形式:（i,j,v）
				其中 v 表示非 0 元素的值，i 表示 v 所在的行号，j 表示 v 所在的列号
```c
//稀疏矩阵的结构题
typedef struct{
	int i,j;//存储非 0 元素的下标
	ELEMType v; //存储非 0 元素的值
}triTerm;

typedef struct{
	int rows,cols; //矩阵的行数、列数
	int terms; //非 0 元素个数
	triTerm tri[maxSize]; //三元组表
}SparseMatrix;
//任意次序输入三元组来生成三元组表的程序实现如下:
int readSparseMatrix(SparseMatrix *M,int r,int c)
int i, j, v, k = 0;
int temp = 0;

M->rows = r;
M->cols = c;
M->terms = 0;           // 刚开始没有元素

// 第一次读入
scanf("%d %d %d", &i, &j, &v);

// 当 i 或 j 为负数时结束输入（常见约定）
while (i >= 0 && i < r && j >= 0 && j < c) {

    temp = 0;
    
    // 第一层 while：跳过 行号 < 当前 i 的所有元素
    while (temp >= 0 && temp < M->terms && M->tri[temp].i < i)
        temp++;

    // 第二层 while：同一行内，跳过 列号 < 当前 j 的元素
    while (temp >= 0 && temp < M->terms && M->tri[temp].i == i && M->tri[temp].j < j)
        temp++;

    // 此时 temp 就是应该插入的位置（或者正好是已有相同 (i,j) 的位置）

    // 后移所有元素，给 temp 位置腾出空间
    for (k = M->terms; k > temp; k--) {
        M->tri[k].i = M->tri[k-1].i;
        M->tri[k].j = M->tri[k-1].j;
        M->tri[k].v = M->tri[k-1].v;
    }

    // 插入新元素
    M->tri[temp].i = i;   // 注意这里用的是 temp，而不是 k
    M->tri[temp].j = j;
    M->tri[temp].v = v;

    M->terms++;           // 非0元素个数增加

    // 继续读下一组
    scanf("%d %d %d", &i, &j, &v);
}

return TRUE;

```
