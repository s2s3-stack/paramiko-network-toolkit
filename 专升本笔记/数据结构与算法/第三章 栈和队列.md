## 栈(==操作受限的线性表==)
	仅一端进行删除和插入的线性表,能进行插入和删除的称为==栈顶==,另一端称为==栈底==(bottom)
		入栈操作及出栈操作只能在栈顶进行，实际上，只能看到栈顶元素，栈顶之下的所有元素都是不可见的，即不允许访问非栈顶元素。
	push:在栈顶插入一个元素
	pop:在栈顶删除一个元素
	栈中每一个元素的类型用:ELEMType
		typedef int ELEMType
	栈的基本操作:
		栈的抽象数据类型:Stack
		int initStack(stack *mys
		int clear(Stack *mys); //将栈 mys 清空
		int pop(Stack *mys,ELEMType *x); //将栈顶元素出栈
		int push(Stack *mys,ELEMType x); //将元素 x 入栈
		int gettop(SeqStack *mys,ELEMType *x);
		//获取栈顶元素(不出栈)
		int isEmpty(Stack *mys); //如果栈 mys 为空,则返回 1,否则返回 0
		int isFull(Stack *mys); //如果栈 mys 为满,则返回 1,否则返回 0
		栈的特性:
			后进先出
栈的存储及实现
## 顺序存储
	采用数组保存栈元素
	获取栈顶元素:
```				int gettop(SeqStack *mys,ELEMType *x)
				//返回栈顶元素（不出栈）
				{if(isEmpty(mys)==FALSE){ 
				*x=mys->element[mys->top-1]; #mys->element mys栈读取元素的位置
				return TRUE;
				}
				else{
				printf("栈空\n");
				return FALSE
				}
				}	
top 的值既是保存下一个入栈元素的位置，也是栈中所含元素个数的计数器				
```
入栈函数
```c
// 入栈函数：将元素x压入顺序栈
int push(SeqStack *mys, ELEMType x) {
    // 先判断栈是否未满
    if (isFull(mys) == FALSE) {
        // 把x存入栈顶位置，然后栈顶指针top+1
        mys->element[mys->top++] = x;
    } else {
        printf("栈满\n");
        return FALSE; // 栈满，入栈失败
    }
    return TRUE; // 入栈成功
}

// 出栈函数：将栈顶元素弹出，并用*x返回弹出的元素
int pop(SeqStack *mys, ELEMType *x) {
    // 先判断栈是否非空
    if (isEmpty(mys) == FALSE) {
        // 栈顶指针top先-1，再取出对应位置的元素赋值给*x
        *x = mys->element[--mys->top];
        return TRUE; // 出栈成功
    } else {
        printf("栈空\n");
        return FALSE; // 栈空，出栈失败
    }
}
```
入栈时，栈顶指针减 1，出栈时，栈顶指针加 1
==例题:==
若一个栈保存在数组 V[0..n-1]中，初始时栈顶指针 top 为 n，则下列选项中，  
能够正确实现 x 入栈操作的语句序列是（top=top-1;V[top]=x; ）。
	**栈顶指针的初始位置是 `n`（在数组外面）**，所以入栈必须先让 `top` 减小到数组的有效范围（`n-1`），再存元素
对顶栈
	对顶栈是 “两个栈共享一个数组” 的节省空间的设计：
		- 栈 1 栈底在数组左端，入栈 `top1++`；
		- 栈 2 栈底在数组右端，入栈 `top2--`；
		- 栈满条件：`top1 == top2 + 1`（两个栈刚好占满数组）。
**top 指向「下一个空位置」**（不是栈顶元素的位置）
	对应规则：
		入栈时：先把元素存入 `element[top]`，再 `top++`（指针后移，指向新的空位置）；
		出栈时：先 `--top`（指针回退，指向栈顶元素的位置），再取 `element[top]`。
	补充 `--top` 和 `top--` 的区别
		`--s.top`（前置减减），如果写成 `s.top--`（后置减减）
			--s.top,先减 1（top=0），再取值
				==因为 `top` 指向 “下一个空位置”，出栈必须**先回退指针**（`--top`），再取值==
					top 指向空位置 → 入栈先存后加、出栈先减后取”
			s.top--,先取值（element [1]，随机垃圾值），再减 1（top=0）

## 链式栈及其实现
	链式栈
		仅在表头操作的单链表
		链式栈的定义
```c
			typedef int ELEMType; #将int类型别名为ELEMType
			typedef struct node{ //开始设计叫node的结构体
			ELEMType data; #定义类型是数字,也就是说这里存的是需要处理的数字
			struct node *next; #指向下一个格子的指针
			LinkStackNode; #struct node 的别名
			typedef LinkStackNode *LinkStack; //将LinkStackNode * 起一个别名LinkStack,链式栈
```
通过pop判断栈不为空,并且出栈后讲栈顶元素的值通过x返回给调用者,元素所占用的空间要释放
```c
int pop(LinkStack *mys,ELEMType *x) {
    LinkStackNode *temp; // 定义临时指针，用来存要删除的结点地址
    if(isEmpty(*mys)==FALSE){ // 栈非空，才能出栈
        // 第一步：把栈顶元素的值传给外部（你的理解：*x带到外部 ✅）
        *x = (*mys)->data; 
        
        // 第二步：保存栈顶结点的地址到temp（关键！不然后续找不到这个结点）
        temp = (*mys); 
        
        // 第三步：移动栈顶指针，跳过原栈顶结点（栈“抛弃”这个结点）
        *mys = (*mys)->next; 
        
        // 第四步：销毁temp指向的原栈顶结点（释放内存，你的理解：销毁 ✅）
        free(temp); 
        
        return TRUE; // 出栈成功
    } else {
        printf("栈空\n");
        return FALSE;
    }
}
如果没有 `temp`，执行 `*mys = (*mys)->next` 后，原栈顶结点的地址就丢了，没法释放，会造成 “内存泄漏”（占着内存用不了）。
整个出栈流程：拿值（`*x`）→ 记地址（`temp`）→ 移指针（`*mys`）→ 毁结点（`free`），一步都不能少（少了 free 会内存泄漏，少了 temp 会找不到要销毁的结点）。
```
入栈操作
```c
int push(LinkStack *mys,ELEMType x) { // x是要入栈的元素值
    LinkStackNode *p; // 定义指针p，用来指向新创建的结点
    
    // 第一步：造结点——为新结点分配内存空间
    p=(LinkStackNode *)malloc(sizeof(LinkStackNode));
    // malloc的作用：向系统申请一块“能存下LinkStackNode大小”的内存，返回这块内存的地址；
    // (LinkStackNode *)是强制类型转换，让地址能赋值给p（因为p是LinkStackNode*类型）；
    
    if(p!=NULL){ // 第二步：内存分配成功（能造出新结点）
        p->data=x; // 给新结点的data赋值：把要入栈的x存进去
        p->next=(*mys); // 新结点的next指向“当前栈顶结点”（把新结点接在原栈顶前面）
        (*mys)=p; // 第三步：移动栈顶指针——让栈顶指向新结点（新结点变成新栈顶）
    } else { // 内存分配失败（比如系统内存满了）
        printf("栈满\n"); // 链式栈理论上没有“栈满”，只有内存不足
        return FALSE; // 入栈失败
    }
    return TRUE; // 入栈成功
}
例如:
假设当前链式栈的状态是：栈顶结点 A（data=10）→ 结点 B（data=20）→ NULL，现在要入栈 x=30：

1. **造积木（malloc）**：`p = malloc(...)` → 申请一块内存，造一个空积木 p；
2. **填内容（p->data=x）**：给积木 p 写上 30（`p->data=30`）；
3. **接积木（p->next=*mys）**：把积木 p 的 “尾巴” 连到原栈顶积木 A 上（`p->next=A`）；
4. **移栈顶（*mys=p）**：把 “栈顶标记” 从 A 移到 p 上 → 新栈顶是 p（data=30）。

最终栈的状态：栈顶 p（30）→ A（10）→ B（20）→ NULL。
```
顺序栈和链式栈的比较
	顺序栈:顺序栈需要预先申请一个固定长度的一维数组，并自始至终全部占用。当栈中元素个  
	数相对较少时，空间浪费较大
	链式栈:链式栈的长度可变，但是每个元素都需要一个指针域，这又产生了==结构性空间开销==。链式栈的空间可能会非常零碎，且需要在程序中==动态申请及释放== 

## 队列
 
先进先出原则(FIFO)
		队列（queue）是只能在表的一端插入、在另一端删除的线性表能进行插入的一端称为队列尾，简称队尾；能进行删除的一端称为队列头，简称队头。	  
		front 指示的是队头元素所在的位置，rear 指示的是队尾元素后面的空位置 
		队列为空的条件是 rear=front，队列为满的条件是(rear+1)%n=front
循环队列的实现
```c
入队操作需要先确认队列不满，然后将元素值保存在 rear 指向的单元中，同时修改
rear 值。出队操作要先确认队列不空，然后将保存在 front 指向的单元中的元素值通过变
量 x 返回给调用者，同时更新 front 值

#define maxSize 100  // 队列最大容量
typedef int ELEMType; // 队列元素类型（比如int）

// 顺序循环队列结构体
typedef struct {
    ELEMType element[maxSize]; // 存储队列元素的数组
    int front; // 队头指针：指向「当前队头元素的位置」
    int rear;  // 队尾指针：指向「下一个入队的空位置」
} SeqQueue;
int enqueue(SeqQueue *myq,ELEMType x) { // 入队函数：把x加入队列
    // 1. 先判断队列是否满，满了就入队失败，返回FALSE
    if(isFull(myq)==TRUE) return FALSE;
    
    // 2. 核心入队操作（拆成两步看更清楚）：
    // 第一步：myq->rear % maxSize → 计算当前队尾要存元素的下标（循环特性）
    // 第二步：把x存入这个下标位置；然后rear++（队尾指针后移，指向新的空位置）
    myq->element[(myq->rear++) % maxSize] = x;
    
    // 3. 入队成功，返回TRUE
    return TRUE;
}
int dequeue(SeqQueue *myq,ELEMType *x) { // 出队函数：把队头元素传给外部的x
    // 1. 先判断队列是否空，空了就出队失败，返回FALSE（注意你代码里FAISE是笔误，应该是FALSE）
    if(isEmpty(myq)==TRUE) return FALSE;
    
    // 2. 核心出队操作（拆成三步，这是你最关心的部分）：
    // 第一步：myq->front % maxSize → 计算当前队头元素的下标（循环特性）；
    // 第二步：把该下标对应的队头元素赋值给 *x（传给外部调用者）；
    // 第三步：front++（队头指针后移，指向「原队头的下一个元素」，也就是新的队头）；
    *x = myq->element[(myq->front++) % maxSize];
    
    // 3. 出队成功，返回TRUE
    return TRUE;
}
实例逻辑:
假设 `maxSize=5`，队列里已入队 10、20、30，此时：
- `front=0`（指向队头元素 10），`rear=3`（指向空位置 3）；
- 调用`dequeue(&q, &val)`出队：   
    1. 计算 `front%maxSize = 0%5 = 0`；
    2. `*x = element[0] = 10` → 把 10 传给外部的`val`；
    3. `front++` → `front=1`（现在指向新的队头元素 20）；   
- 再次调用`dequeue(&q, &val)`：
    1. `front%maxSize =1%5=1`；
    2. `*x=element[1]=20` → 传给外部的`val`；
    3. `front++` → `front=2`（指向新队头 30）；
```
链式队列实现
	当不能确定队列中同时保存的元素个数的上限时，可以采用链式存储方式，即使用一个单链表保存队列
在链式队列中，因为不需要头结点，所以初始化操作中，只给队头指针和队尾指针分  
别赋初值 NULL。队列清空操作需要做两件事，首先将队列中的所有结点从队列中删除，并  
释放所占用的空间，其次将队列的头指针和尾指针赋值为 NULL。
```c
int initQueue(LinkQueue *myq) //构造一个空队列 myq  
{(*myq).front=NULL;  
(*myq).rear=NULL;  
return TRUE;  
}  
// 把返回值从BOOL改成int，返回清空的元素数
int clear(LinkQueue *myq) {
    LinkQueueNode*temp;
    int counter=0;
    temp=(*myq).front;
    while(temp!=NULL){
        (*myq).front=(*myq).front->next;
        free(temp);
        temp=(*myq).front;
        counter++;
    }
    (*myq).front=NULL;
    (*myq).rear=NULL;
    return counter; // 返回循环次数（清空的元素数）
}
// 调用时：int num = clear(&q); printf("清空了%d个元素", num);

- 用临时指针 `temp` 保存当前结点地址；
- 队头指针后移，避免丢失后续结点；
- `free(temp)` 销毁当前结点；
- 循环直到所有结点销毁，最后把 `front` 和 `rear` 都置空（避免野指针）。
```
实现操作
```c
// 入队函数末尾多了一个{，出队函数有拼写错误returm→return、myg→myq、少分号
// 修正后的完整代码（先贴出来，后面按这个讲）：
int enqueue(LinkQueue *myq,ELEMType x) { // 入队 x
    LinkQueueNode *temp;
    temp=(LinkQueueNode*)malloc(sizeof(LinkQueueNode));
    if(temp==NULL) return FALSE;
    temp->data=x;
    temp->next=NULL;
    if((*myq).front==NULL){ // 处理第一个元素入队
        (*myq).front=temp;
        (*myq).rear=temp;
    }
    else{ // 处理非第一个元素入队
        (*myq).rear->next=temp; // 新结点链在队尾
        (*myq).rear=temp; // 更新尾指针（注意原代码是冒号，要改成分号）
    }
    return TRUE;
}

int dequeue(LinkQueue *myq,ELEMType *x) { // 出队，并通过x返回
    LinkQueueNode *temp;
    if(isEmpty(myq)==TRUE){
        printf("队列为空\n");
        return FALSE; 
    }
    *x=(*myq).front->data;
    temp=(*myq).front;
    (*myq).front=temp->next;
    if((*myq).front==NULL) (*myq).rear=NULL; // 唯一元素出队（原代码myg是拼写错误）
    free(temp);
    return TRUE;
}
为什么`front`和`rear`都指向`temp`？
因为队列只有一个结点，这个结点既是队头也是队尾，必须让两个指针都指向它，否则后续入队 / 出队会找不到结点。

freeN的概念

```

双端队列
	在队头、队尾两端均能够进行入队、出队操作的队列称为双端队列
	- **输入受限的双端队列**：只能从一端入队，但可以从两端出队（比如：只能左端入队，左右两端都能出队）
	- **输出受限的双端队列**：可以从两端入队，但只能从一端出队（比如：只能左端出队，左右两端都能入队）
栈和队列相互模拟
	**用两个栈（S 和 T）模拟实现队列的入队操作**，核心是利用栈 “后进先出” 的特性，通过两个栈的 “倒腾” 来模拟队列 “先进先出” 的逻辑
```c
int enqueuesimuQ(simuQueue *simuq,ELEMType x) { // 模拟队列的入队函数，x是要入队的元素
    ELEMType temp; // 临时变量，用来存从S弹出的元素
    
    // 场景1：输入栈S还没满 → 直接把x压入S（入队成功）
    if(isFull(simuq->S) == FALSE) {
        push(&simuq->S, x); // 压入S
        return TRUE;
    }
    
    // 场景2：输入栈S已满 → 尝试腾空间
    else {
        // 子场景2.1：输出栈T为空 → 可以把S的元素倒到T里
        if(isEmpty(simuq->T) == TRUE) {
            // 循环：只要S不为空 且 T还没满，就把S的元素弹出，压入T
            while(isEmpty(simuq->S) == FALSE && isFull(simuq->T) == FALSE) {
                pop(&simuq->S, &temp); // 弹出S的栈顶元素到temp
                push(&simuq->T, temp); // 把temp压入T
            }
            
            // 倒完后检查：如果S还有元素（说明T也满了，队列真的满了）
            if(isEmpty(simuq->S) == FALSE) {
                return FALSE; // 入队失败
            }
            // 倒完后S为空 → 把新元素x压入S
            else {
                push(&simuq->S, x);
                return TRUE; // 入队成功
            }
        }
        
        // 子场景2.2：输出栈T不为空 → 无法腾空间，队列已满
        else {
            return FALSE; // 入队失败
        }
    }
}
```
模拟栈
```c
- 把主队列 P 里的元素（除最后一个）移到辅助队列 Q；
- 取出 P 里剩下的最后一个元素（栈顶，通过`*x`返回）；
- 再把辅助队列 Q 里的元素移回主队列 P，恢复 P 的状态（为下次操作做准备）。

typedef struct {
    Queue P; // 主队列：存储栈的元素
    Queue Q; // 辅助队列：临时存放元素，实现栈的“后进先出”
} simuStack;
int popsimuS(simuStack *simus,ELEMType *x) { // 模拟栈的出栈函数，x返回栈顶元素
    ELEMType temp; // 临时变量，存队列出队的元素
    
    // 场景1：主队列P为空 → 栈空，出栈失败
    if(isEmpty(simus->P) == TRUE) {
        return FALSE;
    }
    
    // 场景2：主队列P非空 → 开始倒腾元素，找栈顶（最后入队的元素）
    // 第一个while循环：把P里除最后一个元素外，都移到Q
    while(isEmpty(simus->P) == FALSE) {
        // 从P出队一个元素，存在temp里
        dequeue(simus->P, &temp);
        // 关键判断：如果P还不为空（说明当前temp不是最后一个元素），就把temp入队到Q
        if(isEmpty(simus->P) == FALSE) {
            enqueue(simus->Q, temp);
        }
        // 如果P为空（说明temp是最后一个元素，就是栈顶），不加入Q，留着返回
    }
    
    // 此时temp就是P里最后一个元素（栈顶），赋值给*x返回
    *x = temp;
    printf("x=%d", *x); // 打印栈顶元素，方便调试
    
    // 第二个while循环：把Q里的元素移回P，恢复P的状态
    while(isEmpty(simus->Q) == FALSE) {
        // 从Q出队一个元素到temp
        dequeue(simus->Q, &temp);
        // 把temp入队到P
        enqueue(simus->P, temp);
    }
    
    return TRUE; // 出栈成功
}

```

让两个队列轮流做主队列及辅助队列
可以增加一个奇偶标志 flag 以避免元素的过多移动
```c
#include <stdio.h>
#include <stdlib.h>

// 补充隐含的类型定义（模拟栈依赖的队列/元素类型）
#define maxSize 10 // 队列最大容量
typedef int ELEMType;

// 队列结构体（顺序循环队列）
typedef struct {
    ELEMType element[maxSize];
    int front, rear;
} Queue;

// 模拟栈结构体（两个队列实现栈）
typedef struct {
    Queue P; // 主队列
    Queue Q; // 辅助队列
} simuStack;

// 补充隐含的函数声明（你代码里调用的）
int initsimuS(simuStack *simus);    // 初始化模拟栈
int lengthsimuS(simuStack *simus);  // 统计模拟栈长度
int pushsimuS(simuStack *simus, ELEMType x); // 模拟栈入栈
int popsimuS(simuStack *simus, ELEMType *x); // 模拟栈出栈（你之前问的函数）
// 队列基础函数（隐含）
int initQueue(Queue *q); // 初始化队列
int isEmpty(Queue *q);   // 判断队列空
int isFull(Queue *q);    // 判断队列满
int enqueue(Queue *q, ELEMType x); // 队列入队
int dequeue(Queue *q, ELEMType *x); // 队列出队

// 你的main函数（修正后）
int main(int argc,char ** argv) {
    simuStack mys;
    int i, j; // 修正：内层循环用j，避免覆盖i
    ELEMType k=0;
    
    // 步骤1：初始化模拟栈 + 打印初始长度
    i = initsimuS(&mys); // 初始化成功返回TRUE（比如1）
    printf("length=%d\n", lengthsimuS(&mys)); // 初始栈空，长度=0
    
    // 步骤2：尝试出空栈
    if(popsimuS(&mys,&k)==FALSE) 
        printf("空\n");
    
    // 步骤3：循环入栈0~5（共6个元素）
    for(i=0; i<6; i++) {
        if(pushsimuS(&mys,i)==FALSE) 
            printf("满 i=%d\n",i); // 入栈失败才打印
    }
    printf("length=%d\n", lengthsimuS(&mys)); // 入栈6个元素后，长度=6
    
    // 步骤4：循环出栈4次
    for(i=0; i<4; i++) {
        if(popsimuS(&mys,&k)==TRUE) 
            printf("k=%d i=%d\n",k,i);
        else 
            printf("空 i=%d\n",i);
    }
    
    printf("\n");
    
    // 步骤5：循环入栈6~9（共4个元素）
    for(i=6; i<10; i++) {
        if(pushsimuS(&mys,i)==FALSE) 
            printf("满 i=%d\n",i);
    }
    printf("length=%d\n", lengthsimuS(&mys)); // 入栈后长度=2（步骤4剩2）+4=6
    
    // 步骤6：循环出栈6次（i=4~9）
    for(j=4; j<10; j++) { // 修正：用j，避免和外层i冲突
        if(popsimuS(&mys,&k)==TRUE) 
            printf("k=%d j=%d\n",k,j); // 改i为j，避免混淆
        else 
            printf("空 j=%d\n",j);
    }
    
    printf("\n");
    return 0; // 标准main返回0
}
```

第四节 栈和队列的应用
	括号必须成对出现，并且可以嵌套但不能交错。
- ✅ 合法：`[(0)]` → 括号嵌套正确，一一对应
- ❌ 非法：`[(])` → 括号交错，左中括号 `[` 和右圆括号 `)` 不匹配
- 这个算法就是用栈来 “记住” 所有遇到的开括号，当遇到闭括号时，就去栈里找 “最近的那个开括号” 来配对。如果配对不上，或者最后栈里还有没配对的开括号，就说明括号不合法。
三种表达式计算
	前缀表达式
		运算符在两个操作数前面,例如:+ 3 4
			① 从**右往左**扫描表达式；
			② 遇到**操作数**，直接压入栈；
			③ 遇到**运算符**，弹出栈顶两个操作数（注意顺序：先弹的是右操作数，后弹的是左操作数），用运算符计算，结果压回栈；
			④ 扫描结束后，栈里只剩一个数，就是最终结果。
	中缀表达式
		运算符在两个操作数中间,例如:3 + 4
	后缀表达式
		运算符在两个操作数后面,例如:3 4 +
			① 从**左往右**扫描表达式；
			② 遇到**操作数**，直接压入栈；
			③ 遇到**运算符**，弹出栈顶两个操作数（注意顺序：先弹的是右操作数，后弹的是左操作数），用运算符计算，结果压回栈；
			④ 扫描结束后，栈里只剩一个数，就是最终结果。
	输出杨辉三角形
```c
#include <stdio.h>
#include <stdlib.h>

// 补充队列的前置定义（代码隐含）
#define maxSize 100 // 队列最大容量
typedef int ELEMType;

// 顺序循环队列结构体
typedef struct {
    ELEMType element[maxSize];
    int front, rear; // 队头/队尾指针
} SeqQueue;

// 队列基础函数（必须实现）
int initQueue(SeqQueue *q) { // 初始化队列
    q->front = q->rear = 0;
    return 1;
}

int enqueue(SeqQueue *q, ELEMType x) { // 入队
    if((q->rear + 1) % maxSize == q->front) return 0; // 满队
    q->element[q->rear] = x;
    q->rear = (q->rear + 1) % maxSize;
    return 1;
}

int dequeue(SeqQueue *q, ELEMType *x) { // 出队
    if(q->front == q->rear) return 0; // 空队
    *x = q->element[q->front];
    q->front = (q->front + 1) % maxSize;
    return 1;
}

// 修正：输出n个空格（原代码printf("")无效果）
void printblank(int n) {
    int i;
    for(i=0; i<n; i++) {
        printf(" "); // 输出空格，实现杨辉三角的缩进
    }
}

// 杨辉三角核心函数
void yangTri(int n) {
    SeqQueue myq;
    int i,j,first,second,add;
    initQueue(&myq); // 初始化空队列
    
    // 第一步：打印第一行（只有1）
    printblank(n-1); // 缩进n-1个空格（让三角居中）
    printf("1\n");
    enqueue(&myq, 1); // 把第一行的1入队，供第二行计算使用
    
    // 第二步：打印第2行到第n行
    for(i=2; i<=n; i++) { // i表示当前行数
        printblank(n-i); // 缩进n-i个空格（行数越大，缩进越少）
        
        // 初始化当前行的第一个数为1（杨辉三角每行以1开头）
        first = 1;
        printf("%d", first); // 打印当前行第一个1
        
        // 计算并打印当前行的中间数值（共i-2个，因为首尾都是1）
        for(j=1; j<=i-2; j++) { // j从1到i-2，循环i-2次
            dequeue(&myq, &second); // 出队上一行的下一个数
            add = first + second; // 两数之和（杨辉三角核心规则）
            printf(" %d", add); // 打印和（加空格分隔）
            enqueue(&myq, add); // 把和入队，供下一行计算
            first = second; // 更新first为当前second，为下一次求和做准备
        }
        
        // 打印当前行最后一个1（杨辉三角每行以1结尾）
        printf(" %d\n", 1);
        enqueue(&myq, 1); // 把最后一个1入队，供下一行计算
    }
}

// 测试主函数
int main(int argc, char **argv) {
    int n;
    printf("输出的杨辉三角形的行数 n 是:");
    scanf("%d", &n); // 输入要打印的行数
    yangTri(n); // 调用函数打印杨辉三角
    return 0;
}
```