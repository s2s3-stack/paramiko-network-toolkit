线性表
	线性表中的每个元素都是唯一的,且依次排列
	线性表中最常见的两种操作:
		加入
		删除
	线性表定义:
		同类数据元素构成的有限序列
			第一个元素:==a0==称为表头元素和开始元素
			最后一个元素==an-1==,称为表尾元素或终端元素
			元素的个数==n==称为表长
			当==n=0==时,线性表为空表  
			有序表
			无序表(常用):
				表中的值不满足按位置顺序递增或递减关系的线性表
			线性表的三个特点:
				所有元素属于同一个类型
				元素个数是有限的
				各元素之间不一定有大小关系,但一定有次序关系
		线性表的抽象数据类型:
 ```
			线性表的抽象数据类型定义:
				ADTLinearList
			数据部分:
				L //线性表
			操作部分:
				int initList(LinearList *L) //初始化线性表,创建一个空表L
				int clear(LinearList *L) //将表L置空
				int isEmpty(LinearList *L) //如果L为空,则返回1,否则返回0
				int isFull(LinearList *L) //如果表L为满,则返回1,否则返回0
				int length(LinearList *L) //返回表L的当前长度
				int insertList(LinearList *L,Position pos,ELEMType x)
				//在表L的位置pos处插入元素x
				int removeList(LinearList *L,Position pos,ELEMType *x)
				//删除表L中位置pos处的元素并通过x返回
				int setValue(LinearList *L,position pos,ELEMType x)
				//给表L位置pos处的元素赋值x
				int getValue(LinearList *L,position pos,ELEMType *x)
				//返回表L中位置pos处的元素
				Position find(LinearList *L,ELEMType x)
				//返回元素x在表L中第一次出现的位置
 ```
顺序表的==存储结构==
	顺序存储
		一组==连续==的存储单元
		==需预先分配存储空间,空间一旦分配,将无法修改==
			预留空间过大,可能会导致资源浪费
				分配完数组之后,元素会依次从==a0到an-1==依次填充
				首个元素所处的地址是首地址
```
		#求一维数组下某一个元素的存储单元地址
		LOC(a0)=LOC(a0)+i*d 
		//a0是首元素的存储地址,i为目标元素的下标位置,d为每个元素占用的存储单元大小
```
	顺序表的==**插入删除**==操作:
		从尾元素到待插入元素之间的元素依次后移,将位置空出来,插入待插入元素
		从待删元素的下一个元素向前移动进行覆盖
			插入删除都需要移动约表中一半的元素
				==插入 平均移动2分之n==
				==删除 平均移动2分之n-1==
					此处时间复杂度为O(n),与插入和删除的位置有关
		顺序表的基本操作实现
		
```
		定义常亮
			#define TRUE 1
			#define FALSE 0
			#define ERROR -1
			#ifndef maxSize
			#define maxSize 100 //类似python中maxSize = 100
			#endif	
		顺序表的定义
			typedef int ELEMType 
			typedef struct{
				ELEMType element[maxSize] //数组内可存储的最大数量
				//类似python中的int(maxSize)
				int n; //定于顺序表中的元素个数
			}seqList //定义该结构体为顺序表
			typedef SeqList LinearList //定义一个顺序结构的线性表
			typedef int Position	// 定义数组的位置
		顺序表的操作
			int initList(SeqList *L) //初始化顺序表,创建空表L
			}L->N=0
			return TURE //此处返回1
			}
			int clear(SeqList *L) //将表长置空
			}L->N=0
			return TURE //此处返回1
			}
		#判空
			int isEmpty(SeqList *L) *是指针类型说明符,表明变量是一个指针(存储的是另外一个变量内存地址),L指向了顺序表对象
			//如果L为空则返回1,否则返回0
			{if(L->n==0)return TRUE //类似(*L).n==0
			else return FALSE
			}
		#判满
			int isfull(SeqList *L) //如果L满,则返回1,否则返回0
			{if (L->n==maxSize)return TRUE
			else return FALSE
			}
			int length(SeqList *L)//返回当前的长度
			{return L->n

			}
```
==在进行插入和删除操作一定要进行合法性检查,也就是0<=i<=n==
```
	插入操作的完整代码:
	int insertList(SeqList *L,Position pos,ELEMType x) 
	//在表L的位置pos处插入元素x
	{int i;
	if(isFull(L)==TURE)return FASLE;
	if(pos<0||pos>L->n)return ERROR //位置错误
	}
	for(i=L->n;i>pos;i++) 
	//获取指针 `L` 所指向的顺序表结构体中的 `n` 成员（表长），并将该值赋值给变量 `i`
	L->element[i]=L->element[i-1]
	//将原位置的元素向前移
	}
	L->element[i]=x 
	//把数值 `x` 写入到顺序表指针 `L` 所指向的、`element` 数组的第 `i` 个下标位置」
	L->n++; //表长+1
	return TRUE
	}
	
	删除操作的完整代码:
	int removelist(Seqlist *L,Position pos,ELEMType *X)
	//表明 `X` 是一个指向 `ELEMType` 类型数据的指针变量
	//删除表L中位置pos处的元素并通过x返回
	{int i;
	if(isEmpty(L)==TURE)return FALSE
	ir(pos<0||pos>L->n-1)return ERROR
	*x=L->element[pos] //记下被删除的元素
	for(i=pos;i<L->n-1;i++){
	L->element[i]=L->element[i+1]; //前移元素
	}
	L->n--; //表长减1
	return TRUE
	
	setvalue #查找位置插入元素
	
	Positionfind #查找元素位置
	positionfind(seqlist *L,ELEMTyoe x) //返回元素x在表L中第一次出现的位置
	{int i;
	for(i=0;i<L->n;i++)
	if(L->element[i]==x)return x //如果找到x的对应位置,返回x
	return ERROR
	}
	
	
	实战:
	元素逆置,以数组中间元素为界,将中间元素左边和右边的元素进行交换
	int reverse(seqlist *L) #将顺序表逆置
	{
	int i,len=L->n;
	if(len==0)return TRUE; //空表
	for(i=o;i<len/2;i++)swap(&(L->element[i].&(L->element[len-i-1]));
	return TRUE;
	}
		#swap函数的实现:
		void swap(ELEMType *X,ELEMType *y)
		{
		ELEMType temp;
		temp=*x;
		*x=*y
		*y=temp
		}
```
	

链式存储
		节点:线性表的各个元素保存在各自的存储空间,形成一个个节点
		节点在内存中的辞职不要求相邻,之间通过指针链接
		单链表:只有一个指针域
			节点资源动态分配
			每个节点保存线性表的一个元素及一个指针
			指针指向后继元素的节点
			==设置头指针==(因为元素在内存中的位置不确定,所以必须从某个指针开始)
			为了解决上诉问题,在首节点前面添加一个类型相同的头节点
```
	typedef int ELEMType;
	typedef struct node{
	ELEMType data //数据域
	struct node *next 
	//存储的是下一个同类型节点的 “门牌号”（内存地址），通过它能找到下一个节点。
	}linkNode
	typedef LinkNode *LinkList
	//一个 `LinkNode` 变量就是一个具体的链表节点（占据一块内存，包含 `data` 和 `next`）；
	typedef int position //位置
```
插入操作:
	在位置2处插入元素E后得到的线性表(A B E C D),在单链表L上插入的操作步骤是:
	1,创建一个新节点,新节点中保存值E
	2,让新节点的next指针指向指针curr指针指向的节点 //curr指当前指针
	3,让当前节点的直接前驱节点的next指针指向新节点
删除操作:
	找到被==删除节点的前驱节点==,如果没有指针利用,需要从表头指针开始延链的方向逐步后移,从而找到相应的位置
	例如:
	**A B C需要删除B**
		curr->next=p->next
```
代表头节点为空的语句
	head->next==null

带头节点的单链表基本操作实现:

// 构造一个带头节点的空单链表
int initList(LinkList *head)
{
    // 为头节点分配内存空间，将内存地址赋值给*head（链表头指针）
    (*head) = (LinkList)malloc(sizeof(LinkNode));
    
    // 判断内存分配是否失败（头节点是否创建成功）
    if (*head == NULL)
        return FALSE;
    
    // 在头节点的data域中记录链表长度（初始为空链表，长度为0）
    (*head)->data = 0;
    // 头节点的next域置为空，标识链表末尾（无有效节点）
    (*head)->next = NULL;
    
    // 链表初始化成功，返回成功标识
    return TRUE;
}
```
	==setvalue的时间复杂度O(n)==
	==getvalue的时间复杂度O(n)==
指针指向节点的位置:
```
setPos函数
编写setPos函数,返回指针curr指向节点的位置
// 返回curr指向节点的位置

Position setPos(LinkList *head, LinkNode *curr)
{
    LinkNode *temp = *head;
    int count = 0;
    
    // 容错：判断指针是否有效
    if (*head == NULL || curr == NULL) {
        printf("指针无效\n");
        // 补充：指针无效时返回一个标识值（此处返回-1，代表位置无效）
        return -1;
    }
    
    // 遍历链表，查找curr节点的位置
    while (temp != curr && temp != NULL) {
        temp = temp->next;
        count++;
    }
    
    return count;
}
```
	
	循环链表
		head->next==head //判空条件
		和非循环链表的区别:
			非循环链表只能从表节点进行遍历
			循环链表可以设置尾节点进行遍历
	双向链表
		较于单链表,多了一个指向前驱节点的prv指针
		head->prev==head->next //判空条件

```
DouLinkNode *setCurr(DouLinkList *head,Position pos) 设置当前指针的值
DouLinkNode *temp=*head
if(*head==NULL)
printf("表头指针无效")
return NULL
```
	双链表的插入删除操作:
	A B(p) C  插入B
	p->prev=P->next->prev
	p->next=p->prev->next
	
	A(curr) B(p) C  删除B
	curr->next=curr->next->next

第四节-链表和顺序表的区别
	单链表的优点:
		适合频繁插入删除的场景,支持随机存取
	缺点:
		每个节点需要额外的指针开销
	顺序表的优点:
		顺序存储是通过数组存储数据的,因此可以通过索引下标直接定位元素位置
	缺点:
		顺序表基本适用于插入元素比较少或者基本不插入新元素的场景,因为插入删除操作都会移动元素位置
	空闲单元链表：
		适合经常插入删除的场景
		将删除的链表放入到空闲链表,后续在使用的话,直接从空闲链表提取,减少malloc和free的调用所消耗的时间
	静态链表
		不进行插入删除的链表

第五节-==单链表的应用(程序题考的居多)==
	通过输入元素个数,然后依次读入响应个数的整数值,使用这些值构造一个带头节点的单链表

```
// 查找倒数第 k 个结点
LinkNode *findKth(LinkList *head, int k) 
{
    LinkNode *front, *rear;
    int i, flag = 1;

    // 容错：k必须是正整数
    if (k <= 0) {
        printf("k 必须大于零!");
        return NULL;
    }

    // 【原代码bug】此处缺失大括号，导致return NULL无条件执行，需补充
    if (*head == NULL) {
        printf("链表错误\n");
        return NULL;
    }

    // 初始化快慢指针，都指向头节点
    front = *head;
    rear = *head;

    // 快指针先走k步
    for (i = 0; i < k; i++) {
        if (front != NULL) {
            front = front->next;
        } else {
            // 提前走到链表末尾，说明k超过表长
            flag = 0;
            break;
        }
    }

    // 判断k是否超过链表长度
    if (!flag) {
        printf("k 值大于表长!");
        return NULL;
    }

    // 快慢指针同步走，直到快指针到末尾
    while (front != NULL) {
        front = front->next;
        rear = rear->next;
    }

    // 返回倒数第k个节点的指针
    return rear;
}

```
查找单链表倒数第k个节点
	已知单链表有n个节点,则倒数第k个节点即第n-k+1个节点
	对链表长度位置的情况下,可通过以下快慢指针来实现倒数第k个节点的定位
```
// 查找倒数第 k 个结点
LinkNode *findKth(LinkList *head, int k) 
{
    LinkNode *front, *rear;
    int i, flag = 1;

    // 容错：k必须是正整数
    if (k <= 0) {
        printf("k 必须大于零!");
        return NULL;
    }

    if (*head == NULL) {
        printf("链表错误\n");
        return NULL;
    }

    // 初始化快慢指针，都指向头节点
    front = *head;
    rear = *head;

    // 快指针先走k步
    for (i = 0; i < k; i++) {
        if (front != NULL) {
            front = front->next;
        } else {
            // 提前走到链表末尾，说明k超过表长
            flag = 0;
            break;
        }
    }

    // 判断k是否超过链表长度
    if (!flag) {
        printf("k 值大于表长!");
        return NULL;
    }

    // 快慢指针同步走，直到快指针到末尾
    while (front != NULL) {
        front = front->next;
        rear = rear->next;
    }

    // 返回倒数第k个节点的指针
    return rear;
}
```
