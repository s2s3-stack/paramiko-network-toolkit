数据依赖
	概念:指系统之间存在各种联系，他是通过一个关系中属性间值的相等与否
	函数依赖(FD):
		概念:一个属性的值可以确定另一个属性的值,例如:学号Sno->姓名Sname
		具体类型:
			部分依赖:
				如果X的真子集(去掉一个属性后的剩余集合)也能确定Y,那么X->Y就是部分依赖
					例如:(学号Sno,课程号Cno) -> Sname,去掉Cno,仍然能够唯一确定Sname
			完全依赖:
				X的任意真子集都不能确定Y,只有X才能确定Y
					例如:(学号Sno,课程号Cno)->grade成绩,单独的学号不能唯一标识成绩,因为一个学生可以选修多门课,课程号也不能唯一标识成绩,同一个课程号可以被多个学生选修
			传递依赖:
				传递依赖是指：**属性`X`确定`Y`，`Y`又确定`A`，但`Y`不能反过来确定`X`，且`A`不是`X`的一部分**，此时`X → A`就是传递依赖（通过`Y`“间接”确定)
					例如:学号->课程号,课程号->教师，但是课程号不能确定学号,因为课程号可以被多名学生选修,教师也不是学号的一部分,因此学号->教师是传递依赖
			平凡依赖:
				分析：`X = {sNo, cNo}`（两个属性），`Y = {cNo}`（一个属性），`Y`是`X`的真子集（`cNo`在`X`里，且`X`比`Y`多`sNo`）。所以这个依赖是**平凡依赖**（相当于“用包含cNo的组合去确定cNo自己”，必然成立）。
			非平凡依赖:
				分析：`X = {sNo, cNo}`（属性是sNo、cNo），`Y = {grade}`（属性是grade），`grade`不在`X`里，所以`Y`不是`X`的真子集。因此这个依赖是**非平凡依赖**（成绩不是学号或课程号的一部分，需要通过组合来确定）。
关系模式的范式:
	评判关系模式的好坏的标准就是模式的范式(NF)
		关系模式的规范化:
			一个低一级范式的关系模式通过模式分解,化为几个高一级范式的关系模式
		第一范式(1NF):属于原子性,每个属性值都不可再分
			存在问题:
				数据冗余过大,插入异常,删除异常,修改异常
		第二范式(2NF):在1NF的基础上,消除部分依赖
			例如:SC(Sno,Cno,Score,Cname),(Sno,Cno为主键),Sno,Cno->Cname,Cno->Cname,但是Sno!->Cname,此处存在局部依赖,因为将SC进行分解
				R1(Sno,Cno,Score)
				R2(Sno,Cno,Cname)
				判断一个关系是否属于第二范式:
					第一步:找出数据中所有的候选键
					第二步:找出所有主属性和非主属性
					第三步:判断非主属性对候选键的部分函数依赖
		第三范式(3NF):在2NF的基础上消除传递函数依赖
			例如:(Cno,Cname,Tno,Tname),Cno->Tno,Tno->Tname,此处存在传递依赖,将关系进行分解,消除传递依赖
				R3(Cno,Cname,Tno)
				R4(Tno,Tname)
		BCNF范式:在3NF的基础上,消除主属性对主键的部分和传递依赖(决定因素:超键)
		第四范式:消除表中的多值依赖
	关系模式的规范化步骤:
		采用"模式分解"
			第一步:如果R不满足2NF,则对R进行投影,消除原模式中非主属性对键的部分依赖
			第二步:如果R满足2NF但不满足3NF,则对R进行投影，消除原模式中非主属性对键的传递依赖
			第三步:如果R满足3NF，但不满足BCNF,则对R进行投影,消除原模式中主属性对键的传递依赖
			
			
			
			